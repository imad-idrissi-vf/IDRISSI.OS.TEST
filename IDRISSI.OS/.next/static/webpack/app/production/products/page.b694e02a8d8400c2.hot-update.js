"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/production/products/page",{

/***/ "(app-pages-browser)/./lib/products/product-store.ts":
/*!***************************************!*\
  !*** ./lib/products/product-store.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProductStore: () => (/* binding */ useProductStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _product_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./product-data */ \"(app-pages-browser)/./lib/products/product-data.ts\");\n\n\nconst useProductStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        products: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        filteredProducts: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        searchTerm: \"\",\n        statusFilter: \"all\",\n        collectionFilter: \"\",\n        tagFilter: [],\n        setSearchTerm: (term)=>{\n            set({\n                searchTerm: term\n            });\n            applyFilters(get, set);\n        },\n        setStatusFilter: (status)=>{\n            set({\n                statusFilter: status\n            });\n            applyFilters(get, set);\n        },\n        setCollectionFilter: (collection)=>{\n            set({\n                collectionFilter: collection\n            });\n            applyFilters(get, set);\n        },\n        setTagFilter: (tags)=>{\n            set({\n                tagFilter: tags\n            });\n            applyFilters(get, set);\n        },\n        addProduct: (productData)=>{\n            const id = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n            const margin = calculateMargin(productData.costPrice, productData.retailPrice);\n            const newProduct = {\n                ...productData,\n                id,\n                margin\n            };\n            set((state)=>({\n                    products: [\n                        ...state.products,\n                        newProduct\n                    ]\n                }));\n            applyFilters(get, set);\n        },\n        updateProduct: (id, productData)=>{\n            set((state)=>{\n                const updatedProducts = state.products.map((product)=>{\n                    if (product.id === id) {\n                        // Recalculate margin if prices changed\n                        let margin = product.margin;\n                        if (productData.costPrice !== undefined && productData.retailPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, productData.retailPrice);\n                        } else if (productData.costPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, product.retailPrice);\n                        } else if (productData.retailPrice !== undefined) {\n                            margin = calculateMargin(product.costPrice, productData.retailPrice);\n                        }\n                        return {\n                            ...product,\n                            ...productData,\n                            margin\n                        };\n                    }\n                    return product;\n                });\n                return {\n                    products: updatedProducts\n                };\n            });\n            applyFilters(get, set);\n        },\n        archiveProduct: (id)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>product.id === id ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        duplicateProduct: (id)=>{\n            set((state)=>{\n                const productToDuplicate = state.products.find((p)=>p.id === id);\n                if (!productToDuplicate) return state;\n                const newId = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n                const duplicatedProduct = {\n                    ...productToDuplicate,\n                    id: newId,\n                    name: \"\".concat(productToDuplicate.name, \" (Copy)\"),\n                    sku: \"\".concat(productToDuplicate.sku, \"-COPY\"),\n                    status: \"draft\"\n                };\n                return {\n                    products: [\n                        ...state.products,\n                        duplicatedProduct\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        bulkArchive: (ids)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkDuplicate: (ids)=>{\n            set((state)=>{\n                const productsToDuplicate = state.products.filter((p)=>ids.includes(p.id));\n                const duplicatedProducts = productsToDuplicate.map((product)=>({\n                        ...product,\n                        id: \"PRD-\".concat(Math.floor(Math.random() * 10000)),\n                        name: \"\".concat(product.name, \" (Copy)\"),\n                        sku: \"\".concat(product.sku, \"-COPY\"),\n                        status: \"draft\"\n                    }));\n                return {\n                    products: [\n                        ...state.products,\n                        ...duplicatedProducts\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        // Add these implementations to the store creation\n        isSkuUnique: (sku, currentProductId)=>{\n            const products = get().products;\n            return !products.some((product)=>product.sku === sku && product.id !== currentProductId);\n        },\n        getAvailableProductTypes: ()=>[\n                \"T-shirt\",\n                \"Hoodie\",\n                \"Sweatshirt\",\n                \"Jacket\",\n                \"Pants\",\n                \"Shorts\",\n                \"Hat\",\n                \"Accessory\",\n                \"Footwear\",\n                \"Other\"\n            ],\n        addCollection: (collection)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        addWarehouse: (warehouse)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        removeWarehouse: (warehouse)=>{\n            // In a real app, this would remove from a database and update products\n            set((state)=>({\n                    products: state.products.map((product)=>product.warehouse === warehouse ? {\n                            ...product,\n                            warehouse: \"\"\n                        } : product)\n                }));\n        },\n        bulkChangeCollection: (ids, collection)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            collection\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkAddTags: (ids, tags)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (ids.includes(product.id)) {\n                            const currentTags = product.tags || [];\n                            const newTags = [\n                                ...new Set([\n                                    ...currentTags,\n                                    ...tags\n                                ])\n                            ];\n                            return {\n                                ...product,\n                                tags: newTags\n                            };\n                        }\n                        return product;\n                    })\n                }));\n            applyFilters(get, set);\n        },\n        bulkDelete: (ids)=>{\n            set((state)=>({\n                    products: state.products.filter((product)=>!ids.includes(product.id))\n                }));\n            applyFilters(get, set);\n        },\n        addNoteToProduct: (id, note)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (product.id === id) {\n                            const noteEntry = {\n                                id: \"note-\".concat(Date.now()),\n                                text: note,\n                                timestamp: new Date(),\n                                user: \"Current User\"\n                            };\n                            const currentNotes = product.notes || [];\n                            return {\n                                ...product,\n                                notes: [\n                                    noteEntry,\n                                    ...currentNotes\n                                ]\n                            };\n                        }\n                        return product;\n                    })\n                }));\n        }\n    }));\n// Helper function to calculate margin\nfunction calculateMargin(costPrice, retailPrice) {\n    if (costPrice === 0) return 0;\n    return Math.round((retailPrice - costPrice) / retailPrice * 100);\n}\n// Helper function to apply all filters\nfunction applyFilters(get, set) {\n    const { products, searchTerm, statusFilter, collectionFilter, tagFilter } = get();\n    let filtered = [\n        ...products\n    ];\n    // Apply search filter\n    if (searchTerm) {\n        const term = searchTerm.toLowerCase();\n        filtered = filtered.filter((product)=>product.name.toLowerCase().includes(term) || product.sku.toLowerCase().includes(term));\n    }\n    // Apply status filter\n    if (statusFilter !== \"all\") {\n        filtered = filtered.filter((product)=>product.status === statusFilter);\n    }\n    // Apply collection filter\n    if (collectionFilter) {\n        filtered = filtered.filter((product)=>product.collection === collectionFilter);\n    }\n    // Apply tag filter\n    if (tagFilter.length > 0) {\n        filtered = filtered.filter((product)=>{\n            var _product_tags;\n            return (_product_tags = product.tags) === null || _product_tags === void 0 ? void 0 : _product_tags.some((tag)=>tagFilter.includes(tag));\n        });\n    }\n    set({\n        filteredProducts: filtered\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9kdWN0cy9wcm9kdWN0LXN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNGO0FBK0R0QyxNQUFNRSxrQkFBa0JGLCtDQUFNQSxDQUFlLENBQUNHLEtBQUtDLE1BQVM7UUFDakVDLFVBQVVKLHVEQUFZQTtRQUN0Qkssa0JBQWtCTCx1REFBWUE7UUFDOUJNLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxrQkFBa0I7UUFDbEJDLFdBQVcsRUFBRTtRQUViQyxlQUFlLENBQUNDO1lBQ2RULElBQUk7Z0JBQUVJLFlBQVlLO1lBQUs7WUFDdkJDLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFXLGlCQUFpQixDQUFDQztZQUNoQlosSUFBSTtnQkFBRUssY0FBY087WUFBTztZQUMzQkYsYUFBYVQsS0FBS0Q7UUFDcEI7UUFFQWEscUJBQXFCLENBQUNDO1lBQ3BCZCxJQUFJO2dCQUFFTSxrQkFBa0JRO1lBQVc7WUFDbkNKLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFlLGNBQWMsQ0FBQ0M7WUFDYmhCLElBQUk7Z0JBQUVPLFdBQVdTO1lBQUs7WUFDdEJOLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFpQixZQUFZLENBQUNDO1lBQ1gsTUFBTUMsS0FBSyxPQUF5QyxPQUFsQ0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUs7WUFDN0MsTUFBTUMsU0FBU0MsZ0JBQWdCTixZQUFZTyxTQUFTLEVBQUVQLFlBQVlRLFdBQVc7WUFFN0UsTUFBTUMsYUFBYTtnQkFDakIsR0FBR1QsV0FBVztnQkFDZEM7Z0JBQ0FJO1lBQ0Y7WUFFQXZCLElBQUksQ0FBQzRCLFFBQVc7b0JBQ2QxQixVQUFVOzJCQUFJMEIsTUFBTTFCLFFBQVE7d0JBQUV5QjtxQkFBVztnQkFDM0M7WUFFQWpCLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUE2QixlQUFlLENBQUNWLElBQUlEO1lBQ2xCbEIsSUFBSSxDQUFDNEI7Z0JBQ0gsTUFBTUUsa0JBQWtCRixNQUFN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L1VzZXJzL2kuaWRyaXNzaS9Eb3dubG9hZHMvZmluYW5jaWFsLWRhc2hib2FyZCAoMykvbGliL3Byb2R1Y3RzL3Byb2R1Y3Qtc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlLCB0eXBlIFNldFN0YXRlIH0gZnJvbSBcInp1c3RhbmRcIlxuaW1wb3J0IHsgbW9ja1Byb2R1Y3RzIH0gZnJvbSBcIi4vcHJvZHVjdC1kYXRhXCJcblxuZXhwb3J0IHR5cGUgUHJvZHVjdFN0YXR1cyA9IFwiYWN0aXZlXCIgfCBcImRyYWZ0XCIgfCBcImFyY2hpdmVkXCJcblxuLy8gVXBkYXRlIHRoZSBQcm9kdWN0IGludGVyZmFjZSB0byBpbmNsdWRlIHByb2R1Y3RUeXBlXG5leHBvcnQgaW50ZXJmYWNlIFByb2R1Y3Qge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBza3U6IHN0cmluZ1xuICBjb2xsZWN0aW9uPzogc3RyaW5nXG4gIHByb2R1Y3RUeXBlPzogc3RyaW5nXG4gIGNvc3RQcmljZTogbnVtYmVyXG4gIHJldGFpbFByaWNlOiBudW1iZXJcbiAgbWFyZ2luOiBudW1iZXJcbiAgc3RhdHVzOiBQcm9kdWN0U3RhdHVzXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIHF1YW50aXR5PzogbnVtYmVyXG4gIHdhcmVob3VzZT86IHN0cmluZ1xuICByZXN0b2NrVGhyZXNob2xkPzogbnVtYmVyXG4gIGltYWdlcz86IHN0cmluZ1tdXG4gIG5vdGVzPzogTm90ZUVudHJ5W11cbiAgdGFncz86IHN0cmluZ1tdXG59XG5cbi8vIEFkZCBhIG5ldyBpbnRlcmZhY2UgZm9yIG5vdGUgZW50cmllc1xuZXhwb3J0IGludGVyZmFjZSBOb3RlRW50cnkge1xuICBpZDogc3RyaW5nXG4gIHRleHQ6IHN0cmluZ1xuICB0aW1lc3RhbXA6IERhdGVcbiAgdXNlcjogc3RyaW5nXG59XG5cbmludGVyZmFjZSBQcm9kdWN0U3RvcmUge1xuICBwcm9kdWN0czogUHJvZHVjdFtdXG4gIGZpbHRlcmVkUHJvZHVjdHM6IFByb2R1Y3RbXVxuICBzZWFyY2hUZXJtOiBzdHJpbmdcbiAgc3RhdHVzRmlsdGVyOiBQcm9kdWN0U3RhdHVzIHwgXCJhbGxcIlxuICBjb2xsZWN0aW9uRmlsdGVyOiBzdHJpbmdcbiAgdGFnRmlsdGVyOiBzdHJpbmdbXVxuXG4gIHNldFNlYXJjaFRlcm06ICh0ZXJtOiBzdHJpbmcpID0+IHZvaWRcbiAgc2V0U3RhdHVzRmlsdGVyOiAoc3RhdHVzOiBQcm9kdWN0U3RhdHVzIHwgXCJhbGxcIikgPT4gdm9pZFxuICBzZXRDb2xsZWN0aW9uRmlsdGVyOiAoY29sbGVjdGlvbjogc3RyaW5nKSA9PiB2b2lkXG4gIHNldFRhZ0ZpbHRlcjogKHRhZ3M6IHN0cmluZ1tdKSA9PiB2b2lkXG5cbiAgYWRkUHJvZHVjdDogKHByb2R1Y3Q6IE9taXQ8UHJvZHVjdCwgXCJpZFwiIHwgXCJtYXJnaW5cIj4pID0+IHZvaWRcbiAgdXBkYXRlUHJvZHVjdDogKGlkOiBzdHJpbmcsIHByb2R1Y3Q6IFBhcnRpYWw8UHJvZHVjdD4pID0+IHZvaWRcbiAgYXJjaGl2ZVByb2R1Y3Q6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGR1cGxpY2F0ZVByb2R1Y3Q6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGJ1bGtBcmNoaXZlOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxuICBidWxrRHVwbGljYXRlOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxuICAvLyBBZGQgdGhlc2UgZnVuY3Rpb25zIHRvIHRoZSBQcm9kdWN0U3RvcmUgaW50ZXJmYWNlXG4gIGlzU2t1VW5pcXVlOiAoc2t1OiBzdHJpbmcsIGN1cnJlbnRQcm9kdWN0SWQ/OiBzdHJpbmcpID0+IGJvb2xlYW5cbiAgZ2V0QXZhaWxhYmxlUHJvZHVjdFR5cGVzOiAoKSA9PiBzdHJpbmdbXVxuICBhZGRDb2xsZWN0aW9uOiAoY29sbGVjdGlvbjogc3RyaW5nKSA9PiB2b2lkXG4gIGFkZFdhcmVob3VzZTogKHdhcmVob3VzZTogc3RyaW5nKSA9PiB2b2lkXG4gIHJlbW92ZVdhcmVob3VzZTogKHdhcmVob3VzZTogc3RyaW5nKSA9PiB2b2lkXG4gIGJ1bGtDaGFuZ2VDb2xsZWN0aW9uOiAoaWRzOiBzdHJpbmdbXSwgY29sbGVjdGlvbjogc3RyaW5nKSA9PiB2b2lkXG4gIGJ1bGtBZGRUYWdzOiAoaWRzOiBzdHJpbmdbXSwgdGFnczogc3RyaW5nW10pID0+IHZvaWRcbiAgYnVsa0RlbGV0ZTogKGlkczogc3RyaW5nW10pID0+IHZvaWRcbiAgYWRkTm90ZVRvUHJvZHVjdDogKGlkOiBzdHJpbmcsIG5vdGU6IHN0cmluZykgPT4gdm9pZFxufVxuXG5leHBvcnQgY29uc3QgdXNlUHJvZHVjdFN0b3JlID0gY3JlYXRlPFByb2R1Y3RTdG9yZT4oKHNldCwgZ2V0KSA9PiAoe1xuICBwcm9kdWN0czogbW9ja1Byb2R1Y3RzLFxuICBmaWx0ZXJlZFByb2R1Y3RzOiBtb2NrUHJvZHVjdHMsXG4gIHNlYXJjaFRlcm06IFwiXCIsXG4gIHN0YXR1c0ZpbHRlcjogXCJhbGxcIixcbiAgY29sbGVjdGlvbkZpbHRlcjogXCJcIixcbiAgdGFnRmlsdGVyOiBbXSxcblxuICBzZXRTZWFyY2hUZXJtOiAodGVybSkgPT4ge1xuICAgIHNldCh7IHNlYXJjaFRlcm06IHRlcm0gfSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgc2V0U3RhdHVzRmlsdGVyOiAoc3RhdHVzKSA9PiB7XG4gICAgc2V0KHsgc3RhdHVzRmlsdGVyOiBzdGF0dXMgfSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgc2V0Q29sbGVjdGlvbkZpbHRlcjogKGNvbGxlY3Rpb24pID0+IHtcbiAgICBzZXQoeyBjb2xsZWN0aW9uRmlsdGVyOiBjb2xsZWN0aW9uIH0pXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIHNldFRhZ0ZpbHRlcjogKHRhZ3MpID0+IHtcbiAgICBzZXQoeyB0YWdGaWx0ZXI6IHRhZ3MgfSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYWRkUHJvZHVjdDogKHByb2R1Y3REYXRhKSA9PiB7XG4gICAgY29uc3QgaWQgPSBgUFJELSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApfWBcbiAgICBjb25zdCBtYXJnaW4gPSBjYWxjdWxhdGVNYXJnaW4ocHJvZHVjdERhdGEuY29zdFByaWNlLCBwcm9kdWN0RGF0YS5yZXRhaWxQcmljZSlcblxuICAgIGNvbnN0IG5ld1Byb2R1Y3QgPSB7XG4gICAgICAuLi5wcm9kdWN0RGF0YSxcbiAgICAgIGlkLFxuICAgICAgbWFyZ2luLFxuICAgIH1cblxuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogWy4uLnN0YXRlLnByb2R1Y3RzLCBuZXdQcm9kdWN0XSxcbiAgICB9KSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICB1cGRhdGVQcm9kdWN0OiAoaWQsIHByb2R1Y3REYXRhKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3RzID0gc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiB7XG4gICAgICAgIGlmIChwcm9kdWN0LmlkID09PSBpZCkge1xuICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIG1hcmdpbiBpZiBwcmljZXMgY2hhbmdlZFxuICAgICAgICAgIGxldCBtYXJnaW4gPSBwcm9kdWN0Lm1hcmdpblxuICAgICAgICAgIGlmIChwcm9kdWN0RGF0YS5jb3N0UHJpY2UgIT09IHVuZGVmaW5lZCAmJiBwcm9kdWN0RGF0YS5yZXRhaWxQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXJnaW4gPSBjYWxjdWxhdGVNYXJnaW4ocHJvZHVjdERhdGEuY29zdFByaWNlLCBwcm9kdWN0RGF0YS5yZXRhaWxQcmljZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3REYXRhLmNvc3RQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXJnaW4gPSBjYWxjdWxhdGVNYXJnaW4ocHJvZHVjdERhdGEuY29zdFByaWNlLCBwcm9kdWN0LnJldGFpbFByaWNlKVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvZHVjdERhdGEucmV0YWlsUHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFyZ2luID0gY2FsY3VsYXRlTWFyZ2luKHByb2R1Y3QuY29zdFByaWNlLCBwcm9kdWN0RGF0YS5yZXRhaWxQcmljZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyAuLi5wcm9kdWN0LCAuLi5wcm9kdWN0RGF0YSwgbWFyZ2luIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZHVjdFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHsgcHJvZHVjdHM6IHVwZGF0ZWRQcm9kdWN0cyB9XG4gICAgfSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBhcmNoaXZlUHJvZHVjdDogKGlkKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+IChwcm9kdWN0LmlkID09PSBpZCA/IHsgLi4ucHJvZHVjdCwgc3RhdHVzOiBcImFyY2hpdmVkXCIgfSA6IHByb2R1Y3QpKSxcbiAgICB9KSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBkdXBsaWNhdGVQcm9kdWN0OiAoaWQpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0VG9EdXBsaWNhdGUgPSBzdGF0ZS5wcm9kdWN0cy5maW5kKChwKSA9PiBwLmlkID09PSBpZClcbiAgICAgIGlmICghcHJvZHVjdFRvRHVwbGljYXRlKSByZXR1cm4gc3RhdGVcblxuICAgICAgY29uc3QgbmV3SWQgPSBgUFJELSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApfWBcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZWRQcm9kdWN0ID0ge1xuICAgICAgICAuLi5wcm9kdWN0VG9EdXBsaWNhdGUsXG4gICAgICAgIGlkOiBuZXdJZCxcbiAgICAgICAgbmFtZTogYCR7cHJvZHVjdFRvRHVwbGljYXRlLm5hbWV9IChDb3B5KWAsXG4gICAgICAgIHNrdTogYCR7cHJvZHVjdFRvRHVwbGljYXRlLnNrdX0tQ09QWWAsXG4gICAgICAgIHN0YXR1czogXCJkcmFmdFwiIGFzIFByb2R1Y3RTdGF0dXMsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2R1Y3RzOiBbLi4uc3RhdGUucHJvZHVjdHMsIGR1cGxpY2F0ZWRQcm9kdWN0XSxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGJ1bGtBcmNoaXZlOiAoaWRzKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+XG4gICAgICAgIGlkcy5pbmNsdWRlcyhwcm9kdWN0LmlkKSA/IHsgLi4ucHJvZHVjdCwgc3RhdHVzOiBcImFyY2hpdmVkXCIgfSA6IHByb2R1Y3QsXG4gICAgICApLFxuICAgIH0pKVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGJ1bGtEdXBsaWNhdGU6IChpZHMpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0c1RvRHVwbGljYXRlID0gc3RhdGUucHJvZHVjdHMuZmlsdGVyKChwKSA9PiBpZHMuaW5jbHVkZXMocC5pZCkpXG4gICAgICBjb25zdCBkdXBsaWNhdGVkUHJvZHVjdHMgPSBwcm9kdWN0c1RvRHVwbGljYXRlLm1hcCgocHJvZHVjdCkgPT4gKHtcbiAgICAgICAgLi4ucHJvZHVjdCxcbiAgICAgICAgaWQ6IGBQUkQtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCl9YCxcbiAgICAgICAgbmFtZTogYCR7cHJvZHVjdC5uYW1lfSAoQ29weSlgLFxuICAgICAgICBza3U6IGAke3Byb2R1Y3Quc2t1fS1DT1BZYCxcbiAgICAgICAgc3RhdHVzOiBcImRyYWZ0XCIgYXMgUHJvZHVjdFN0YXR1cyxcbiAgICAgIH0pKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9kdWN0czogWy4uLnN0YXRlLnByb2R1Y3RzLCAuLi5kdXBsaWNhdGVkUHJvZHVjdHNdLFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG4gIC8vIEFkZCB0aGVzZSBpbXBsZW1lbnRhdGlvbnMgdG8gdGhlIHN0b3JlIGNyZWF0aW9uXG4gIGlzU2t1VW5pcXVlOiAoc2t1LCBjdXJyZW50UHJvZHVjdElkKSA9PiB7XG4gICAgY29uc3QgcHJvZHVjdHMgPSBnZXQoKS5wcm9kdWN0c1xuICAgIHJldHVybiAhcHJvZHVjdHMuc29tZSgocHJvZHVjdCkgPT4gcHJvZHVjdC5za3UgPT09IHNrdSAmJiBwcm9kdWN0LmlkICE9PSBjdXJyZW50UHJvZHVjdElkKVxuICB9LFxuXG4gIGdldEF2YWlsYWJsZVByb2R1Y3RUeXBlczogKCkgPT4gW1xuICAgIFwiVC1zaGlydFwiLFxuICAgIFwiSG9vZGllXCIsXG4gICAgXCJTd2VhdHNoaXJ0XCIsXG4gICAgXCJKYWNrZXRcIixcbiAgICBcIlBhbnRzXCIsXG4gICAgXCJTaG9ydHNcIixcbiAgICBcIkhhdFwiLFxuICAgIFwiQWNjZXNzb3J5XCIsXG4gICAgXCJGb290d2VhclwiLFxuICAgIFwiT3RoZXJcIixcbiAgXSxcblxuICBhZGRDb2xsZWN0aW9uOiAoY29sbGVjdGlvbikgPT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYWRkIHRvIGEgZGF0YWJhc2VcbiAgICAvLyBGb3IgdGhpcyBkZW1vLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGFzIHdlJ2xsIGp1c3QgdXNlIHRoZSB2YWx1ZSBkaXJlY3RseVxuICB9LFxuXG4gIGFkZFdhcmVob3VzZTogKHdhcmVob3VzZSkgPT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYWRkIHRvIGEgZGF0YWJhc2VcbiAgICAvLyBGb3IgdGhpcyBkZW1vLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGFzIHdlJ2xsIGp1c3QgdXNlIHRoZSB2YWx1ZSBkaXJlY3RseVxuICB9LFxuXG4gIHJlbW92ZVdhcmVob3VzZTogKHdhcmVob3VzZSkgPT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgcmVtb3ZlIGZyb20gYSBkYXRhYmFzZSBhbmQgdXBkYXRlIHByb2R1Y3RzXG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+XG4gICAgICAgIHByb2R1Y3Qud2FyZWhvdXNlID09PSB3YXJlaG91c2UgPyB7IC4uLnByb2R1Y3QsIHdhcmVob3VzZTogXCJcIiB9IDogcHJvZHVjdCxcbiAgICAgICksXG4gICAgfSkpXG4gIH0sXG5cbiAgYnVsa0NoYW5nZUNvbGxlY3Rpb246IChpZHMsIGNvbGxlY3Rpb24pID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT4gKGlkcy5pbmNsdWRlcyhwcm9kdWN0LmlkKSA/IHsgLi4ucHJvZHVjdCwgY29sbGVjdGlvbiB9IDogcHJvZHVjdCkpLFxuICAgIH0pKVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBidWxrQWRkVGFnczogKGlkcywgdGFncykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiB7XG4gICAgICAgIGlmIChpZHMuaW5jbHVkZXMocHJvZHVjdC5pZCkpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGFncyA9IHByb2R1Y3QudGFncyB8fCBbXVxuICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBbLi4ubmV3IFNldChbLi4uY3VycmVudFRhZ3MsIC4uLnRhZ3NdKV1cbiAgICAgICAgICByZXR1cm4geyAuLi5wcm9kdWN0LCB0YWdzOiBuZXdUYWdzIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZHVjdFxuICAgICAgfSksXG4gICAgfSkpXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGJ1bGtEZWxldGU6IChpZHMpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLmZpbHRlcigocHJvZHVjdCkgPT4gIWlkcy5pbmNsdWRlcyhwcm9kdWN0LmlkKSksXG4gICAgfSkpXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGFkZE5vdGVUb1Byb2R1Y3Q6IChpZCwgbm90ZSkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiB7XG4gICAgICAgIGlmIChwcm9kdWN0LmlkID09PSBpZCkge1xuICAgICAgICAgIGNvbnN0IG5vdGVFbnRyeTogTm90ZUVudHJ5ID0ge1xuICAgICAgICAgICAgaWQ6IGBub3RlLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgdGV4dDogbm90ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVzZXI6IFwiQ3VycmVudCBVc2VyXCIsIC8vIEluIGEgcmVhbCBhcHAsIGdldCBmcm9tIGF1dGggY29udGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50Tm90ZXMgPSBwcm9kdWN0Lm5vdGVzIHx8IFtdXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucHJvZHVjdCwgbm90ZXM6IFtub3RlRW50cnksIC4uLmN1cnJlbnROb3Rlc10gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9kdWN0XG4gICAgICB9KSxcbiAgICB9KSlcbiAgfSxcbn0pKVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIG1hcmdpblxuZnVuY3Rpb24gY2FsY3VsYXRlTWFyZ2luKGNvc3RQcmljZTogbnVtYmVyLCByZXRhaWxQcmljZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKGNvc3RQcmljZSA9PT0gMCkgcmV0dXJuIDBcbiAgcmV0dXJuIE1hdGgucm91bmQoKChyZXRhaWxQcmljZSAtIGNvc3RQcmljZSkgLyByZXRhaWxQcmljZSkgKiAxMDApXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBhbGwgZmlsdGVyc1xuZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKGdldDogKCkgPT4gUHJvZHVjdFN0b3JlLCBzZXQ6IFNldFN0YXRlPFByb2R1Y3RTdG9yZT4pIHtcbiAgY29uc3QgeyBwcm9kdWN0cywgc2VhcmNoVGVybSwgc3RhdHVzRmlsdGVyLCBjb2xsZWN0aW9uRmlsdGVyLCB0YWdGaWx0ZXIgfSA9IGdldCgpXG5cbiAgbGV0IGZpbHRlcmVkID0gWy4uLnByb2R1Y3RzXVxuXG4gIC8vIEFwcGx5IHNlYXJjaCBmaWx0ZXJcbiAgaWYgKHNlYXJjaFRlcm0pIHtcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpXG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAocHJvZHVjdCkgPT4gcHJvZHVjdC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHwgcHJvZHVjdC5za3UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSxcbiAgICApXG4gIH1cblxuICAvLyBBcHBseSBzdGF0dXMgZmlsdGVyXG4gIGlmIChzdGF0dXNGaWx0ZXIgIT09IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcigocHJvZHVjdCkgPT4gcHJvZHVjdC5zdGF0dXMgPT09IHN0YXR1c0ZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IGNvbGxlY3Rpb24gZmlsdGVyXG4gIGlmIChjb2xsZWN0aW9uRmlsdGVyKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QuY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbkZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IHRhZyBmaWx0ZXJcbiAgaWYgKHRhZ0ZpbHRlci5sZW5ndGggPiAwKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QudGFncz8uc29tZSgodGFnKSA9PiB0YWdGaWx0ZXIuaW5jbHVkZXModGFnKSkpXG4gIH1cblxuICBzZXQoeyBmaWx0ZXJlZFByb2R1Y3RzOiBmaWx0ZXJlZCB9KVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsIm1vY2tQcm9kdWN0cyIsInVzZVByb2R1Y3RTdG9yZSIsInNldCIsImdldCIsInByb2R1Y3RzIiwiZmlsdGVyZWRQcm9kdWN0cyIsInNlYXJjaFRlcm0iLCJzdGF0dXNGaWx0ZXIiLCJjb2xsZWN0aW9uRmlsdGVyIiwidGFnRmlsdGVyIiwic2V0U2VhcmNoVGVybSIsInRlcm0iLCJhcHBseUZpbHRlcnMiLCJzZXRTdGF0dXNGaWx0ZXIiLCJzdGF0dXMiLCJzZXRDb2xsZWN0aW9uRmlsdGVyIiwiY29sbGVjdGlvbiIsInNldFRhZ0ZpbHRlciIsInRhZ3MiLCJhZGRQcm9kdWN0IiwicHJvZHVjdERhdGEiLCJpZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm1hcmdpbiIsImNhbGN1bGF0ZU1hcmdpbiIsImNvc3RQcmljZSIsInJldGFpbFByaWNlIiwibmV3UHJvZHVjdCIsInN0YXRlIiwidXBkYXRlUHJvZHVjdCIsInVwZGF0ZWRQcm9kdWN0cyIsIm1hcCIsInByb2R1Y3QiLCJ1bmRlZmluZWQiLCJhcmNoaXZlUHJvZHVjdCIsImR1cGxpY2F0ZVByb2R1Y3QiLCJwcm9kdWN0VG9EdXBsaWNhdGUiLCJmaW5kIiwicCIsIm5ld0lkIiwiZHVwbGljYXRlZFByb2R1Y3QiLCJuYW1lIiwic2t1IiwiYnVsa0FyY2hpdmUiLCJpZHMiLCJpbmNsdWRlcyIsImJ1bGtEdXBsaWNhdGUiLCJwcm9kdWN0c1RvRHVwbGljYXRlIiwiZmlsdGVyIiwiZHVwbGljYXRlZFByb2R1Y3RzIiwiaXNTa3VVbmlxdWUiLCJjdXJyZW50UHJvZHVjdElkIiwic29tZSIsImdldEF2YWlsYWJsZVByb2R1Y3RUeXBlcyIsImFkZENvbGxlY3Rpb24iLCJhZGRXYXJlaG91c2UiLCJ3YXJlaG91c2UiLCJyZW1vdmVXYXJlaG91c2UiLCJidWxrQ2hhbmdlQ29sbGVjdGlvbiIsImJ1bGtBZGRUYWdzIiwiY3VycmVudFRhZ3MiLCJuZXdUYWdzIiwiU2V0IiwiYnVsa0RlbGV0ZSIsImFkZE5vdGVUb1Byb2R1Y3QiLCJub3RlIiwibm90ZUVudHJ5IiwiRGF0ZSIsIm5vdyIsInRleHQiLCJ0aW1lc3RhbXAiLCJ1c2VyIiwiY3VycmVudE5vdGVzIiwibm90ZXMiLCJyb3VuZCIsImZpbHRlcmVkIiwidG9Mb3dlckNhc2UiLCJsZW5ndGgiLCJ0YWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/products/product-store.ts\n"));

/***/ })

});