"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/production/products/page",{

/***/ "(app-pages-browser)/./lib/products/product-store.ts":
/*!***************************************!*\
  !*** ./lib/products/product-store.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProductStore: () => (/* binding */ useProductStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _product_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./product-data */ \"(app-pages-browser)/./lib/products/product-data.ts\");\n\n\nconst useProductStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        products: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        filteredProducts: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        searchTerm: \"\",\n        statusFilter: \"all\",\n        collectionFilter: \"\",\n        tagFilter: [],\n        setSearchTerm: (term)=>{\n            set({\n                searchTerm: term\n            });\n            applyFilters(get, set);\n        },\n        setStatusFilter: (status)=>{\n            set({\n                statusFilter: status\n            });\n            applyFilters(get, set);\n        },\n        setCollectionFilter: (collection)=>{\n            set({\n                collectionFilter: collection\n            });\n            applyFilters(get, set);\n        },\n        setTagFilter: (tags)=>{\n            set({\n                tagFilter: tags\n            });\n            applyFilters(get, set);\n        },\n        addProduct: (productData)=>{\n            const id = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n            const margin = calculateMargin(productData.costPrice, productData.retailPrice);\n            const newProduct = {\n                ...productData,\n                id,\n                margin\n            };\n            set((state)=>({\n                    products: [\n                        ...state.products,\n                        newProduct\n                    ]\n                }));\n            applyFilters(get, set);\n        },\n        updateProduct: (id, productData)=>{\n            set((state)=>{\n                const updatedProducts = state.products.map((product)=>{\n                    if (product.id === id) {\n                        // Recalculate margin if prices changed\n                        let margin = product.margin;\n                        if (productData.costPrice !== undefined && productData.retailPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, productData.retailPrice);\n                        } else if (productData.costPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, product.retailPrice);\n                        } else if (productData.retailPrice !== undefined) {\n                            margin = calculateMargin(product.costPrice, productData.retailPrice);\n                        }\n                        return {\n                            ...product,\n                            ...productData,\n                            margin\n                        };\n                    }\n                    return product;\n                });\n                return {\n                    products: updatedProducts\n                };\n            });\n            applyFilters(get, set);\n        },\n        archiveProduct: (id)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>product.id === id ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        duplicateProduct: (id)=>{\n            set((state)=>{\n                const productToDuplicate = state.products.find((p)=>p.id === id);\n                if (!productToDuplicate) return state;\n                const newId = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n                const duplicatedProduct = {\n                    ...productToDuplicate,\n                    id: newId,\n                    name: \"\".concat(productToDuplicate.name, \" (Copy)\"),\n                    sku: \"\".concat(productToDuplicate.sku, \"-COPY\"),\n                    status: \"draft\"\n                };\n                return {\n                    products: [\n                        ...state.products,\n                        duplicatedProduct\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        bulkArchive: (ids)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkDuplicate: (ids)=>{\n            set((state)=>{\n                const productsToDuplicate = state.products.filter((p)=>ids.includes(p.id));\n                const duplicatedProducts = productsToDuplicate.map((product)=>({\n                        ...product,\n                        id: \"PRD-\".concat(Math.floor(Math.random() * 10000)),\n                        name: \"\".concat(product.name, \" (Copy)\"),\n                        sku: \"\".concat(product.sku, \"-COPY\"),\n                        status: \"draft\"\n                    }));\n                return {\n                    products: [\n                        ...state.products,\n                        ...duplicatedProducts\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        // Add these implementations to the store creation\n        isSkuUnique: (sku, currentProductId)=>{\n            const products = get().products;\n            return !products.some((product)=>product.sku === sku && product.id !== currentProductId);\n        },\n        getAvailableProductTypes: ()=>[\n                \"T-shirt\",\n                \"Hoodie\",\n                \"Sweatshirt\",\n                \"Jacket\",\n                \"Pants\",\n                \"Shorts\",\n                \"Hat\",\n                \"Accessory\",\n                \"Footwear\",\n                \"Other\"\n            ],\n        addCollection: (collection)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        addWarehouse: (warehouse)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        removeWarehouse: (warehouse)=>{\n            // In a real app, this would remove from a database and update products\n            set((state)=>({\n                    products: state.products.map((product)=>product.warehouse === warehouse ? {\n                            ...product,\n                            warehouse: \"\"\n                        } : product)\n                }));\n        },\n        bulkChangeCollection: (ids, collection)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            collection\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkAddTags: (ids, tags)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (ids.includes(product.id)) {\n                            const currentTags = product.tags || [];\n                            const newTags = [\n                                ...new Set([\n                                    ...currentTags,\n                                    ...tags\n                                ])\n                            ];\n                            return {\n                                ...product,\n                                tags: newTags\n                            };\n                        }\n                        return product;\n                    })\n                }));\n            applyFilters(get, set);\n        },\n        bulkDelete: (ids)=>{\n            set((state)=>({\n                    products: state.products.filter((product)=>!ids.includes(product.id))\n                }));\n            applyFilters(get, set);\n        },\n        addNoteToProduct: (id, note)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (product.id === id) {\n                            const noteEntry = {\n                                id: \"note-\".concat(Date.now()),\n                                text: note,\n                                timestamp: new Date(),\n                                user: \"Current User\"\n                            };\n                            const currentNotes = product.notes || [];\n                            return {\n                                ...product,\n                                notes: [\n                                    noteEntry,\n                                    ...currentNotes\n                                ]\n                            };\n                        }\n                        return product;\n                    })\n                }));\n        }\n    }));\n// Helper function to calculate margin\nfunction calculateMargin(costPrice, retailPrice) {\n    if (costPrice === 0) return 0;\n    return Math.round((retailPrice - costPrice) / retailPrice * 100);\n}\n// Helper function to apply all filters\nfunction applyFilters(get, set) {\n    const { products, searchTerm, statusFilter, collectionFilter, tagFilter } = get();\n    let filtered = [\n        ...products\n    ];\n    // Apply search filter\n    if (searchTerm) {\n        const term = searchTerm.toLowerCase();\n        filtered = filtered.filter((product)=>product.name.toLowerCase().includes(term) || product.sku.toLowerCase().includes(term));\n    }\n    // Apply status filter\n    if (statusFilter !== \"all\") {\n        filtered = filtered.filter((product)=>product.status === statusFilter);\n    }\n    // Apply collection filter\n    if (collectionFilter) {\n        filtered = filtered.filter((product)=>product.collection === collectionFilter);\n    }\n    // Apply tag filter\n    if (tagFilter.length > 0) {\n        filtered = filtered.filter((product)=>{\n            var _product_tags;\n            return (_product_tags = product.tags) === null || _product_tags === void 0 ? void 0 : _product_tags.some((tag)=>tagFilter.includes(tag));\n        });\n    }\n    set({\n        filteredProducts: filtered\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9kdWN0cy9wcm9kdWN0LXN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnQztBQUVhO0FBK0R0QyxNQUFNRSxrQkFBa0JGLCtDQUFNQSxDQUFlLENBQUNHLEtBQUtDLE1BQVM7UUFDakVDLFVBQVVKLHVEQUFZQTtRQUN0Qkssa0JBQWtCTCx1REFBWUE7UUFDOUJNLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxrQkFBa0I7UUFDbEJDLFdBQVcsRUFBRTtRQUViQyxlQUFlLENBQUNDO1lBQ2RULElBQUk7Z0JBQUVJLFlBQVlLO1lBQUs7WUFDdkJDLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFXLGlCQUFpQixDQUFDQztZQUNoQlosSUFBSTtnQkFBRUssY0FBY087WUFBTztZQUMzQkYsYUFBYVQsS0FBS0Q7UUFDcEI7UUFFQWEscUJBQXFCLENBQUNDO1lBQ3BCZCxJQUFJO2dCQUFFTSxrQkFBa0JRO1lBQVc7WUFDbkNKLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFlLGNBQWMsQ0FBQ0M7WUFDYmhCLElBQUk7Z0JBQUVPLFdBQVdTO1lBQUs7WUFDdEJOLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFpQixZQUFZLENBQUNDO1lBQ1gsTUFBTUMsS0FBSyxPQUF5QyxPQUFsQ0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUs7WUFDN0MsTUFBTUMsU0FBU0MsZ0JBQWdCTixZQUFZTyxTQUFTLEVBQUVQLFlBQVlRLFdBQVc7WUFFN0UsTUFBTUMsYUFBYTtnQkFDakIsR0FBR1QsV0FBVztnQkFDZEM7Z0JBQ0FJO1lBQ0Y7WUFFQXZCLElBQUksQ0FBQzRCLFFBQVc7b0JBQ2QxQixVQUFVOzJCQUFJMEIsTUFBTTFCLFFBQVE7d0JBQUV5QjtxQkFBVztnQkFDM0M7WUFFQWpCLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUE2QixlQUFlLENBQUNWLElBQUlEO1lBQ2xCbEIsSUFBSSxDQUFDNEI7Z0JBQ0gsTUFBTUUsa0JBQWtCRixNQUFN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L1VzZXJzL2kuaWRyaXNzaS9Eb3dubG9hZHMvZmluYW5jaWFsLWRhc2hib2FyZCAoMykvbGliL3Byb2R1Y3RzL3Byb2R1Y3Qtc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcInp1c3RhbmRcIlxuaW1wb3J0IHR5cGUgeyBTdGF0ZUNyZWF0b3IgfSBmcm9tIFwienVzdGFuZFwiXG5pbXBvcnQgeyBtb2NrUHJvZHVjdHMgfSBmcm9tIFwiLi9wcm9kdWN0LWRhdGFcIlxuXG5leHBvcnQgdHlwZSBQcm9kdWN0U3RhdHVzID0gXCJhY3RpdmVcIiB8IFwiZHJhZnRcIiB8IFwiYXJjaGl2ZWRcIlxuXG4vLyBVcGRhdGUgdGhlIFByb2R1Y3QgaW50ZXJmYWNlIHRvIGluY2x1ZGUgcHJvZHVjdFR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdCB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHNrdTogc3RyaW5nXG4gIGNvbGxlY3Rpb24/OiBzdHJpbmdcbiAgcHJvZHVjdFR5cGU/OiBzdHJpbmdcbiAgY29zdFByaWNlOiBudW1iZXJcbiAgcmV0YWlsUHJpY2U6IG51bWJlclxuICBtYXJnaW46IG51bWJlclxuICBzdGF0dXM6IFByb2R1Y3RTdGF0dXNcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgcXVhbnRpdHk/OiBudW1iZXJcbiAgd2FyZWhvdXNlPzogc3RyaW5nXG4gIHJlc3RvY2tUaHJlc2hvbGQ/OiBudW1iZXJcbiAgaW1hZ2VzPzogc3RyaW5nW11cbiAgbm90ZXM/OiBOb3RlRW50cnlbXVxuICB0YWdzPzogc3RyaW5nW11cbn1cblxuLy8gQWRkIGEgbmV3IGludGVyZmFjZSBmb3Igbm90ZSBlbnRyaWVzXG5leHBvcnQgaW50ZXJmYWNlIE5vdGVFbnRyeSB7XG4gIGlkOiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG4gIHRpbWVzdGFtcDogRGF0ZVxuICB1c2VyOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFByb2R1Y3RTdG9yZSB7XG4gIHByb2R1Y3RzOiBQcm9kdWN0W11cbiAgZmlsdGVyZWRQcm9kdWN0czogUHJvZHVjdFtdXG4gIHNlYXJjaFRlcm06IHN0cmluZ1xuICBzdGF0dXNGaWx0ZXI6IFByb2R1Y3RTdGF0dXMgfCBcImFsbFwiXG4gIGNvbGxlY3Rpb25GaWx0ZXI6IHN0cmluZ1xuICB0YWdGaWx0ZXI6IHN0cmluZ1tdXG5cbiAgc2V0U2VhcmNoVGVybTogKHRlcm06IHN0cmluZykgPT4gdm9pZFxuICBzZXRTdGF0dXNGaWx0ZXI6IChzdGF0dXM6IFByb2R1Y3RTdGF0dXMgfCBcImFsbFwiKSA9PiB2b2lkXG4gIHNldENvbGxlY3Rpb25GaWx0ZXI6IChjb2xsZWN0aW9uOiBzdHJpbmcpID0+IHZvaWRcbiAgc2V0VGFnRmlsdGVyOiAodGFnczogc3RyaW5nW10pID0+IHZvaWRcblxuICBhZGRQcm9kdWN0OiAocHJvZHVjdDogT21pdDxQcm9kdWN0LCBcImlkXCIgfCBcIm1hcmdpblwiPikgPT4gdm9pZFxuICB1cGRhdGVQcm9kdWN0OiAoaWQ6IHN0cmluZywgcHJvZHVjdDogUGFydGlhbDxQcm9kdWN0PikgPT4gdm9pZFxuICBhcmNoaXZlUHJvZHVjdDogKGlkOiBzdHJpbmcpID0+IHZvaWRcbiAgZHVwbGljYXRlUHJvZHVjdDogKGlkOiBzdHJpbmcpID0+IHZvaWRcbiAgYnVsa0FyY2hpdmU6IChpZHM6IHN0cmluZ1tdKSA9PiB2b2lkXG4gIGJ1bGtEdXBsaWNhdGU6IChpZHM6IHN0cmluZ1tdKSA9PiB2b2lkXG4gIC8vIEFkZCB0aGVzZSBmdW5jdGlvbnMgdG8gdGhlIFByb2R1Y3RTdG9yZSBpbnRlcmZhY2VcbiAgaXNTa3VVbmlxdWU6IChza3U6IHN0cmluZywgY3VycmVudFByb2R1Y3RJZD86IHN0cmluZykgPT4gYm9vbGVhblxuICBnZXRBdmFpbGFibGVQcm9kdWN0VHlwZXM6ICgpID0+IHN0cmluZ1tdXG4gIGFkZENvbGxlY3Rpb246IChjb2xsZWN0aW9uOiBzdHJpbmcpID0+IHZvaWRcbiAgYWRkV2FyZWhvdXNlOiAod2FyZWhvdXNlOiBzdHJpbmcpID0+IHZvaWRcbiAgcmVtb3ZlV2FyZWhvdXNlOiAod2FyZWhvdXNlOiBzdHJpbmcpID0+IHZvaWRcbiAgYnVsa0NoYW5nZUNvbGxlY3Rpb246IChpZHM6IHN0cmluZ1tdLCBjb2xsZWN0aW9uOiBzdHJpbmcpID0+IHZvaWRcbiAgYnVsa0FkZFRhZ3M6IChpZHM6IHN0cmluZ1tdLCB0YWdzOiBzdHJpbmdbXSkgPT4gdm9pZFxuICBidWxrRGVsZXRlOiAoaWRzOiBzdHJpbmdbXSkgPT4gdm9pZFxuICBhZGROb3RlVG9Qcm9kdWN0OiAoaWQ6IHN0cmluZywgbm90ZTogc3RyaW5nKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCB1c2VQcm9kdWN0U3RvcmUgPSBjcmVhdGU8UHJvZHVjdFN0b3JlPigoc2V0LCBnZXQpID0+ICh7XG4gIHByb2R1Y3RzOiBtb2NrUHJvZHVjdHMsXG4gIGZpbHRlcmVkUHJvZHVjdHM6IG1vY2tQcm9kdWN0cyxcbiAgc2VhcmNoVGVybTogXCJcIixcbiAgc3RhdHVzRmlsdGVyOiBcImFsbFwiLFxuICBjb2xsZWN0aW9uRmlsdGVyOiBcIlwiLFxuICB0YWdGaWx0ZXI6IFtdLFxuXG4gIHNldFNlYXJjaFRlcm06ICh0ZXJtKSA9PiB7XG4gICAgc2V0KHsgc2VhcmNoVGVybTogdGVybSB9KVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBzZXRTdGF0dXNGaWx0ZXI6IChzdGF0dXMpID0+IHtcbiAgICBzZXQoeyBzdGF0dXNGaWx0ZXI6IHN0YXR1cyB9KVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBzZXRDb2xsZWN0aW9uRmlsdGVyOiAoY29sbGVjdGlvbikgPT4ge1xuICAgIHNldCh7IGNvbGxlY3Rpb25GaWx0ZXI6IGNvbGxlY3Rpb24gfSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgc2V0VGFnRmlsdGVyOiAodGFncykgPT4ge1xuICAgIHNldCh7IHRhZ0ZpbHRlcjogdGFncyB9KVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBhZGRQcm9kdWN0OiAocHJvZHVjdERhdGEpID0+IHtcbiAgICBjb25zdCBpZCA9IGBQUkQtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCl9YFxuICAgIGNvbnN0IG1hcmdpbiA9IGNhbGN1bGF0ZU1hcmdpbihwcm9kdWN0RGF0YS5jb3N0UHJpY2UsIHByb2R1Y3REYXRhLnJldGFpbFByaWNlKVxuXG4gICAgY29uc3QgbmV3UHJvZHVjdCA9IHtcbiAgICAgIC4uLnByb2R1Y3REYXRhLFxuICAgICAgaWQsXG4gICAgICBtYXJnaW4sXG4gICAgfVxuXG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBbLi4uc3RhdGUucHJvZHVjdHMsIG5ld1Byb2R1Y3RdLFxuICAgIH0pKVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIHVwZGF0ZVByb2R1Y3Q6IChpZCwgcHJvZHVjdERhdGEpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdHMgPSBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+IHtcbiAgICAgICAgaWYgKHByb2R1Y3QuaWQgPT09IGlkKSB7XG4gICAgICAgICAgLy8gUmVjYWxjdWxhdGUgbWFyZ2luIGlmIHByaWNlcyBjaGFuZ2VkXG4gICAgICAgICAgbGV0IG1hcmdpbiA9IHByb2R1Y3QubWFyZ2luXG4gICAgICAgICAgaWYgKHByb2R1Y3REYXRhLmNvc3RQcmljZSAhPT0gdW5kZWZpbmVkICYmIHByb2R1Y3REYXRhLnJldGFpbFByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IGNhbGN1bGF0ZU1hcmdpbihwcm9kdWN0RGF0YS5jb3N0UHJpY2UsIHByb2R1Y3REYXRhLnJldGFpbFByaWNlKVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvZHVjdERhdGEuY29zdFByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IGNhbGN1bGF0ZU1hcmdpbihwcm9kdWN0RGF0YS5jb3N0UHJpY2UsIHByb2R1Y3QucmV0YWlsUHJpY2UpXG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0RGF0YS5yZXRhaWxQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXJnaW4gPSBjYWxjdWxhdGVNYXJnaW4ocHJvZHVjdC5jb3N0UHJpY2UsIHByb2R1Y3REYXRhLnJldGFpbFByaWNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IC4uLnByb2R1Y3QsIC4uLnByb2R1Y3REYXRhLCBtYXJnaW4gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9kdWN0XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4geyBwcm9kdWN0czogdXBkYXRlZFByb2R1Y3RzIH1cbiAgICB9KVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGFyY2hpdmVQcm9kdWN0OiAoaWQpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT4gKHByb2R1Y3QuaWQgPT09IGlkID8geyAuLi5wcm9kdWN0LCBzdGF0dXM6IFwiYXJjaGl2ZWRcIiB9IDogcHJvZHVjdCkpLFxuICAgIH0pKVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGR1cGxpY2F0ZVByb2R1Y3Q6IChpZCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByb2R1Y3RUb0R1cGxpY2F0ZSA9IHN0YXRlLnByb2R1Y3RzLmZpbmQoKHApID0+IHAuaWQgPT09IGlkKVxuICAgICAgaWYgKCFwcm9kdWN0VG9EdXBsaWNhdGUpIHJldHVybiBzdGF0ZVxuXG4gICAgICBjb25zdCBuZXdJZCA9IGBQUkQtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCl9YFxuICAgICAgY29uc3QgZHVwbGljYXRlZFByb2R1Y3QgPSB7XG4gICAgICAgIC4uLnByb2R1Y3RUb0R1cGxpY2F0ZSxcbiAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICBuYW1lOiBgJHtwcm9kdWN0VG9EdXBsaWNhdGUubmFtZX0gKENvcHkpYCxcbiAgICAgICAgc2t1OiBgJHtwcm9kdWN0VG9EdXBsaWNhdGUuc2t1fS1DT1BZYCxcbiAgICAgICAgc3RhdHVzOiBcImRyYWZ0XCIgYXMgUHJvZHVjdFN0YXR1cyxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZHVjdHM6IFsuLi5zdGF0ZS5wcm9kdWN0cywgZHVwbGljYXRlZFByb2R1Y3RdLFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYnVsa0FyY2hpdmU6IChpZHMpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT5cbiAgICAgICAgaWRzLmluY2x1ZGVzKHByb2R1Y3QuaWQpID8geyAuLi5wcm9kdWN0LCBzdGF0dXM6IFwiYXJjaGl2ZWRcIiB9IDogcHJvZHVjdCxcbiAgICAgICksXG4gICAgfSkpXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYnVsa0R1cGxpY2F0ZTogKGlkcykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByb2R1Y3RzVG9EdXBsaWNhdGUgPSBzdGF0ZS5wcm9kdWN0cy5maWx0ZXIoKHApID0+IGlkcy5pbmNsdWRlcyhwLmlkKSlcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZWRQcm9kdWN0cyA9IHByb2R1Y3RzVG9EdXBsaWNhdGUubWFwKChwcm9kdWN0KSA9PiAoe1xuICAgICAgICAuLi5wcm9kdWN0LFxuICAgICAgICBpZDogYFBSRC0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gLFxuICAgICAgICBuYW1lOiBgJHtwcm9kdWN0Lm5hbWV9IChDb3B5KWAsXG4gICAgICAgIHNrdTogYCR7cHJvZHVjdC5za3V9LUNPUFlgLFxuICAgICAgICBzdGF0dXM6IFwiZHJhZnRcIiBhcyBQcm9kdWN0U3RhdHVzLFxuICAgICAgfSkpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2R1Y3RzOiBbLi4uc3RhdGUucHJvZHVjdHMsIC4uLmR1cGxpY2F0ZWRQcm9kdWN0c10sXG4gICAgICB9XG4gICAgfSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcbiAgLy8gQWRkIHRoZXNlIGltcGxlbWVudGF0aW9ucyB0byB0aGUgc3RvcmUgY3JlYXRpb25cbiAgaXNTa3VVbmlxdWU6IChza3UsIGN1cnJlbnRQcm9kdWN0SWQpID0+IHtcbiAgICBjb25zdCBwcm9kdWN0cyA9IGdldCgpLnByb2R1Y3RzXG4gICAgcmV0dXJuICFwcm9kdWN0cy5zb21lKChwcm9kdWN0KSA9PiBwcm9kdWN0LnNrdSA9PT0gc2t1ICYmIHByb2R1Y3QuaWQgIT09IGN1cnJlbnRQcm9kdWN0SWQpXG4gIH0sXG5cbiAgZ2V0QXZhaWxhYmxlUHJvZHVjdFR5cGVzOiAoKSA9PiBbXG4gICAgXCJULXNoaXJ0XCIsXG4gICAgXCJIb29kaWVcIixcbiAgICBcIlN3ZWF0c2hpcnRcIixcbiAgICBcIkphY2tldFwiLFxuICAgIFwiUGFudHNcIixcbiAgICBcIlNob3J0c1wiLFxuICAgIFwiSGF0XCIsXG4gICAgXCJBY2Nlc3NvcnlcIixcbiAgICBcIkZvb3R3ZWFyXCIsXG4gICAgXCJPdGhlclwiLFxuICBdLFxuXG4gIGFkZENvbGxlY3Rpb246IChjb2xsZWN0aW9uKSA9PiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBhZGQgdG8gYSBkYXRhYmFzZVxuICAgIC8vIEZvciB0aGlzIGRlbW8sIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgYXMgd2UnbGwganVzdCB1c2UgdGhlIHZhbHVlIGRpcmVjdGx5XG4gIH0sXG5cbiAgYWRkV2FyZWhvdXNlOiAod2FyZWhvdXNlKSA9PiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBhZGQgdG8gYSBkYXRhYmFzZVxuICAgIC8vIEZvciB0aGlzIGRlbW8sIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgYXMgd2UnbGwganVzdCB1c2UgdGhlIHZhbHVlIGRpcmVjdGx5XG4gIH0sXG5cbiAgcmVtb3ZlV2FyZWhvdXNlOiAod2FyZWhvdXNlKSA9PiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCByZW1vdmUgZnJvbSBhIGRhdGFiYXNlIGFuZCB1cGRhdGUgcHJvZHVjdHNcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT5cbiAgICAgICAgcHJvZHVjdC53YXJlaG91c2UgPT09IHdhcmVob3VzZSA/IHsgLi4ucHJvZHVjdCwgd2FyZWhvdXNlOiBcIlwiIH0gOiBwcm9kdWN0LFxuICAgICAgKSxcbiAgICB9KSlcbiAgfSxcblxuICBidWxrQ2hhbmdlQ29sbGVjdGlvbjogKGlkcywgY29sbGVjdGlvbikgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiAoaWRzLmluY2x1ZGVzKHByb2R1Y3QuaWQpID8geyAuLi5wcm9kdWN0LCBjb2xsZWN0aW9uIH0gOiBwcm9kdWN0KSksXG4gICAgfSkpXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGJ1bGtBZGRUYWdzOiAoaWRzLCB0YWdzKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+IHtcbiAgICAgICAgaWYgKGlkcy5pbmNsdWRlcyhwcm9kdWN0LmlkKSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYWdzID0gcHJvZHVjdC50YWdzIHx8IFtdXG4gICAgICAgICAgY29uc3QgbmV3VGFncyA9IFsuLi5uZXcgU2V0KFsuLi5jdXJyZW50VGFncywgLi4udGFnc10pXVxuICAgICAgICAgIHJldHVybiB7IC4uLnByb2R1Y3QsIHRhZ3M6IG5ld1RhZ3MgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9kdWN0XG4gICAgICB9KSxcbiAgICB9KSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYnVsa0RlbGV0ZTogKGlkcykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMuZmlsdGVyKChwcm9kdWN0KSA9PiAhaWRzLmluY2x1ZGVzKHByb2R1Y3QuaWQpKSxcbiAgICB9KSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYWRkTm90ZVRvUHJvZHVjdDogKGlkLCBub3RlKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+IHtcbiAgICAgICAgaWYgKHByb2R1Y3QuaWQgPT09IGlkKSB7XG4gICAgICAgICAgY29uc3Qgbm90ZUVudHJ5OiBOb3RlRW50cnkgPSB7XG4gICAgICAgICAgICBpZDogYG5vdGUtJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICB0ZXh0OiBub3RlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgdXNlcjogXCJDdXJyZW50IFVzZXJcIiwgLy8gSW4gYSByZWFsIGFwcCwgZ2V0IGZyb20gYXV0aCBjb250ZXh0XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1cnJlbnROb3RlcyA9IHByb2R1Y3Qubm90ZXMgfHwgW11cbiAgICAgICAgICByZXR1cm4geyAuLi5wcm9kdWN0LCBub3RlczogW25vdGVFbnRyeSwgLi4uY3VycmVudE5vdGVzXSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2R1Y3RcbiAgICAgIH0pLFxuICAgIH0pKVxuICB9LFxufSkpXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgbWFyZ2luXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXJnaW4oY29zdFByaWNlOiBudW1iZXIsIHJldGFpbFByaWNlOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoY29zdFByaWNlID09PSAwKSByZXR1cm4gMFxuICByZXR1cm4gTWF0aC5yb3VuZCgoKHJldGFpbFByaWNlIC0gY29zdFByaWNlKSAvIHJldGFpbFByaWNlKSAqIDEwMClcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGFsbCBmaWx0ZXJzXG5mdW5jdGlvbiBhcHBseUZpbHRlcnMoZ2V0OiAoKSA9PiBQcm9kdWN0U3RvcmUsIHNldDogU3RhdGVDcmVhdG9yPFByb2R1Y3RTdG9yZT4pIHtcbiAgY29uc3QgeyBwcm9kdWN0cywgc2VhcmNoVGVybSwgc3RhdHVzRmlsdGVyLCBjb2xsZWN0aW9uRmlsdGVyLCB0YWdGaWx0ZXIgfSA9IGdldCgpXG5cbiAgbGV0IGZpbHRlcmVkID0gWy4uLnByb2R1Y3RzXVxuXG4gIC8vIEFwcGx5IHNlYXJjaCBmaWx0ZXJcbiAgaWYgKHNlYXJjaFRlcm0pIHtcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpXG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAocHJvZHVjdCkgPT4gcHJvZHVjdC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHwgcHJvZHVjdC5za3UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSxcbiAgICApXG4gIH1cblxuICAvLyBBcHBseSBzdGF0dXMgZmlsdGVyXG4gIGlmIChzdGF0dXNGaWx0ZXIgIT09IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcigocHJvZHVjdCkgPT4gcHJvZHVjdC5zdGF0dXMgPT09IHN0YXR1c0ZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IGNvbGxlY3Rpb24gZmlsdGVyXG4gIGlmIChjb2xsZWN0aW9uRmlsdGVyKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QuY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbkZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IHRhZyBmaWx0ZXJcbiAgaWYgKHRhZ0ZpbHRlci5sZW5ndGggPiAwKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QudGFncz8uc29tZSgodGFnKSA9PiB0YWdGaWx0ZXIuaW5jbHVkZXModGFnKSkpXG4gIH1cblxuICBzZXQoeyBmaWx0ZXJlZFByb2R1Y3RzOiBmaWx0ZXJlZCB9KVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsIm1vY2tQcm9kdWN0cyIsInVzZVByb2R1Y3RTdG9yZSIsInNldCIsImdldCIsInByb2R1Y3RzIiwiZmlsdGVyZWRQcm9kdWN0cyIsInNlYXJjaFRlcm0iLCJzdGF0dXNGaWx0ZXIiLCJjb2xsZWN0aW9uRmlsdGVyIiwidGFnRmlsdGVyIiwic2V0U2VhcmNoVGVybSIsInRlcm0iLCJhcHBseUZpbHRlcnMiLCJzZXRTdGF0dXNGaWx0ZXIiLCJzdGF0dXMiLCJzZXRDb2xsZWN0aW9uRmlsdGVyIiwiY29sbGVjdGlvbiIsInNldFRhZ0ZpbHRlciIsInRhZ3MiLCJhZGRQcm9kdWN0IiwicHJvZHVjdERhdGEiLCJpZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm1hcmdpbiIsImNhbGN1bGF0ZU1hcmdpbiIsImNvc3RQcmljZSIsInJldGFpbFByaWNlIiwibmV3UHJvZHVjdCIsInN0YXRlIiwidXBkYXRlUHJvZHVjdCIsInVwZGF0ZWRQcm9kdWN0cyIsIm1hcCIsInByb2R1Y3QiLCJ1bmRlZmluZWQiLCJhcmNoaXZlUHJvZHVjdCIsImR1cGxpY2F0ZVByb2R1Y3QiLCJwcm9kdWN0VG9EdXBsaWNhdGUiLCJmaW5kIiwicCIsIm5ld0lkIiwiZHVwbGljYXRlZFByb2R1Y3QiLCJuYW1lIiwic2t1IiwiYnVsa0FyY2hpdmUiLCJpZHMiLCJpbmNsdWRlcyIsImJ1bGtEdXBsaWNhdGUiLCJwcm9kdWN0c1RvRHVwbGljYXRlIiwiZmlsdGVyIiwiZHVwbGljYXRlZFByb2R1Y3RzIiwiaXNTa3VVbmlxdWUiLCJjdXJyZW50UHJvZHVjdElkIiwic29tZSIsImdldEF2YWlsYWJsZVByb2R1Y3RUeXBlcyIsImFkZENvbGxlY3Rpb24iLCJhZGRXYXJlaG91c2UiLCJ3YXJlaG91c2UiLCJyZW1vdmVXYXJlaG91c2UiLCJidWxrQ2hhbmdlQ29sbGVjdGlvbiIsImJ1bGtBZGRUYWdzIiwiY3VycmVudFRhZ3MiLCJuZXdUYWdzIiwiU2V0IiwiYnVsa0RlbGV0ZSIsImFkZE5vdGVUb1Byb2R1Y3QiLCJub3RlIiwibm90ZUVudHJ5IiwiRGF0ZSIsIm5vdyIsInRleHQiLCJ0aW1lc3RhbXAiLCJ1c2VyIiwiY3VycmVudE5vdGVzIiwibm90ZXMiLCJyb3VuZCIsImZpbHRlcmVkIiwidG9Mb3dlckNhc2UiLCJsZW5ndGgiLCJ0YWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/products/product-store.ts\n"));

/***/ })

});