"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/production/products/page",{

/***/ "(app-pages-browser)/./lib/products/product-store.ts":
/*!***************************************!*\
  !*** ./lib/products/product-store.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProductStore: () => (/* binding */ useProductStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _product_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./product-data */ \"(app-pages-browser)/./lib/products/product-data.ts\");\n\n\nconst useProductStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        products: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        filteredProducts: _product_data__WEBPACK_IMPORTED_MODULE_0__.mockProducts,\n        searchTerm: \"\",\n        statusFilter: \"all\",\n        collectionFilter: \"\",\n        tagFilter: [],\n        setSearchTerm: (term)=>{\n            set({\n                searchTerm: term\n            });\n            applyFilters(get, set);\n        },\n        setStatusFilter: (status)=>{\n            set({\n                statusFilter: status\n            });\n            applyFilters(get, set);\n        },\n        setCollectionFilter: (collection)=>{\n            set({\n                collectionFilter: collection\n            });\n            applyFilters(get, set);\n        },\n        setTagFilter: (tags)=>{\n            set({\n                tagFilter: tags\n            });\n            applyFilters(get, set);\n        },\n        addProduct: (productData)=>{\n            const id = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n            const margin = calculateMargin(productData.costPrice, productData.retailPrice);\n            const newProduct = {\n                ...productData,\n                id,\n                margin\n            };\n            set((state)=>({\n                    products: [\n                        ...state.products,\n                        newProduct\n                    ]\n                }));\n            applyFilters(get, set);\n        },\n        updateProduct: (id, productData)=>{\n            set((state)=>{\n                const updatedProducts = state.products.map((product)=>{\n                    if (product.id === id) {\n                        // Recalculate margin if prices changed\n                        let margin = product.margin;\n                        if (productData.costPrice !== undefined && productData.retailPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, productData.retailPrice);\n                        } else if (productData.costPrice !== undefined) {\n                            margin = calculateMargin(productData.costPrice, product.retailPrice);\n                        } else if (productData.retailPrice !== undefined) {\n                            margin = calculateMargin(product.costPrice, productData.retailPrice);\n                        }\n                        return {\n                            ...product,\n                            ...productData,\n                            margin\n                        };\n                    }\n                    return product;\n                });\n                return {\n                    products: updatedProducts\n                };\n            });\n            applyFilters(get, set);\n        },\n        archiveProduct: (id)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>product.id === id ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        duplicateProduct: (id)=>{\n            set((state)=>{\n                const productToDuplicate = state.products.find((p)=>p.id === id);\n                if (!productToDuplicate) return state;\n                const newId = \"PRD-\".concat(Math.floor(Math.random() * 10000));\n                const duplicatedProduct = {\n                    ...productToDuplicate,\n                    id: newId,\n                    name: \"\".concat(productToDuplicate.name, \" (Copy)\"),\n                    sku: \"\".concat(productToDuplicate.sku, \"-COPY\"),\n                    status: \"draft\"\n                };\n                return {\n                    products: [\n                        ...state.products,\n                        duplicatedProduct\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        bulkArchive: (ids)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            status: \"archived\"\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkDuplicate: (ids)=>{\n            set((state)=>{\n                const productsToDuplicate = state.products.filter((p)=>ids.includes(p.id));\n                const duplicatedProducts = productsToDuplicate.map((product)=>({\n                        ...product,\n                        id: \"PRD-\".concat(Math.floor(Math.random() * 10000)),\n                        name: \"\".concat(product.name, \" (Copy)\"),\n                        sku: \"\".concat(product.sku, \"-COPY\"),\n                        status: \"draft\"\n                    }));\n                return {\n                    products: [\n                        ...state.products,\n                        ...duplicatedProducts\n                    ]\n                };\n            });\n            applyFilters(get, set);\n        },\n        // Add these implementations to the store creation\n        isSkuUnique: (sku, currentProductId)=>{\n            const products = get().products;\n            return !products.some((product)=>product.sku === sku && product.id !== currentProductId);\n        },\n        getAvailableProductTypes: ()=>[\n                \"T-shirt\",\n                \"Hoodie\",\n                \"Sweatshirt\",\n                \"Jacket\",\n                \"Pants\",\n                \"Shorts\",\n                \"Hat\",\n                \"Accessory\",\n                \"Footwear\",\n                \"Other\"\n            ],\n        addCollection: (collection)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        addWarehouse: (warehouse)=>{\n        // In a real app, this would add to a database\n        // For this demo, we don't need to do anything as we'll just use the value directly\n        },\n        removeWarehouse: (warehouse)=>{\n            // In a real app, this would remove from a database and update products\n            set((state)=>({\n                    products: state.products.map((product)=>product.warehouse === warehouse ? {\n                            ...product,\n                            warehouse: \"\"\n                        } : product)\n                }));\n        },\n        bulkChangeCollection: (ids, collection)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>ids.includes(product.id) ? {\n                            ...product,\n                            collection\n                        } : product)\n                }));\n            applyFilters(get, set);\n        },\n        bulkAddTags: (ids, tags)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (ids.includes(product.id)) {\n                            const currentTags = product.tags || [];\n                            const newTags = [\n                                ...new Set([\n                                    ...currentTags,\n                                    ...tags\n                                ])\n                            ];\n                            return {\n                                ...product,\n                                tags: newTags\n                            };\n                        }\n                        return product;\n                    })\n                }));\n            applyFilters(get, set);\n        },\n        bulkDelete: (ids)=>{\n            set((state)=>({\n                    products: state.products.filter((product)=>!ids.includes(product.id))\n                }));\n            applyFilters(get, set);\n        },\n        addNoteToProduct: (id, note)=>{\n            set((state)=>({\n                    products: state.products.map((product)=>{\n                        if (product.id === id) {\n                            const noteEntry = {\n                                id: \"note-\".concat(Date.now()),\n                                text: note,\n                                timestamp: new Date(),\n                                user: \"Current User\"\n                            };\n                            const currentNotes = product.notes || [];\n                            return {\n                                ...product,\n                                notes: [\n                                    noteEntry,\n                                    ...currentNotes\n                                ]\n                            };\n                        }\n                        return product;\n                    })\n                }));\n        }\n    }));\n// Helper function to calculate margin\nfunction calculateMargin(costPrice, retailPrice) {\n    if (costPrice === 0) return 0;\n    return Math.round((retailPrice - costPrice) / retailPrice * 100);\n}\n// Helper function to apply all filters\nfunction applyFilters(get, set) {\n    const { products, searchTerm, statusFilter, collectionFilter, tagFilter } = get();\n    let filtered = [\n        ...products\n    ];\n    // Apply search filter\n    if (searchTerm) {\n        const term = searchTerm.toLowerCase();\n        filtered = filtered.filter((product)=>product.name.toLowerCase().includes(term) || product.sku.toLowerCase().includes(term));\n    }\n    // Apply status filter\n    if (statusFilter !== \"all\") {\n        filtered = filtered.filter((product)=>product.status === statusFilter);\n    }\n    // Apply collection filter\n    if (collectionFilter) {\n        filtered = filtered.filter((product)=>product.collection === collectionFilter);\n    }\n    // Apply tag filter\n    if (tagFilter.length > 0) {\n        filtered = filtered.filter((product)=>{\n            var _product_tags;\n            return (_product_tags = product.tags) === null || _product_tags === void 0 ? void 0 : _product_tags.some((tag)=>tagFilter.includes(tag));\n        });\n    }\n    set({\n        filteredProducts: filtered\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9kdWN0cy9wcm9kdWN0LXN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNGO0FBK0R0QyxNQUFNRSxrQkFBa0JGLCtDQUFNQSxDQUFlLENBQUNHLEtBQUtDLE1BQVM7UUFDakVDLFVBQVVKLHVEQUFZQTtRQUN0Qkssa0JBQWtCTCx1REFBWUE7UUFDOUJNLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxrQkFBa0I7UUFDbEJDLFdBQVcsRUFBRTtRQUViQyxlQUFlLENBQUNDO1lBQ2RULElBQUk7Z0JBQUVJLFlBQVlLO1lBQUs7WUFDdkJDLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFXLGlCQUFpQixDQUFDQztZQUNoQlosSUFBSTtnQkFBRUssY0FBY087WUFBTztZQUMzQkYsYUFBYVQsS0FBS0Q7UUFDcEI7UUFFQWEscUJBQXFCLENBQUNDO1lBQ3BCZCxJQUFJO2dCQUFFTSxrQkFBa0JRO1lBQVc7WUFDbkNKLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFlLGNBQWMsQ0FBQ0M7WUFDYmhCLElBQUk7Z0JBQUVPLFdBQVdTO1lBQUs7WUFDdEJOLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUFpQixZQUFZLENBQUNDO1lBQ1gsTUFBTUMsS0FBSyxPQUF5QyxPQUFsQ0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUs7WUFDN0MsTUFBTUMsU0FBU0MsZ0JBQWdCTixZQUFZTyxTQUFTLEVBQUVQLFlBQVlRLFdBQVc7WUFFN0UsTUFBTUMsYUFBYTtnQkFDakIsR0FBR1QsV0FBVztnQkFDZEM7Z0JBQ0FJO1lBQ0Y7WUFFQXZCLElBQUksQ0FBQzRCLFFBQVc7b0JBQ2QxQixVQUFVOzJCQUFJMEIsTUFBTTFCLFFBQVE7d0JBQUV5QjtxQkFBVztnQkFDM0M7WUFFQWpCLGFBQWFULEtBQUtEO1FBQ3BCO1FBRUE2QixlQUFlLENBQUNWLElBQUlEO1lBQ2xCbEIsSUFBSSxDQUFDNEI7Z0JBQ0gsTUFBTUUsa0JBQWtCRixNQUFN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c2Vycy9pLmlkcmlzc2kvRG93bmxvYWRzL2ZpbmFuY2lhbC1kYXNoYm9hcmQgKDMpL2xpYi9wcm9kdWN0cy9wcm9kdWN0LXN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSwgdHlwZSBTZXRTdGF0ZSB9IGZyb20gXCJ6dXN0YW5kXCJcbmltcG9ydCB7IG1vY2tQcm9kdWN0cyB9IGZyb20gXCIuL3Byb2R1Y3QtZGF0YVwiXG5cbmV4cG9ydCB0eXBlIFByb2R1Y3RTdGF0dXMgPSBcImFjdGl2ZVwiIHwgXCJkcmFmdFwiIHwgXCJhcmNoaXZlZFwiXG5cbi8vIFVwZGF0ZSB0aGUgUHJvZHVjdCBpbnRlcmZhY2UgdG8gaW5jbHVkZSBwcm9kdWN0VHlwZVxuZXhwb3J0IGludGVyZmFjZSBQcm9kdWN0IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc2t1OiBzdHJpbmdcbiAgY29sbGVjdGlvbj86IHN0cmluZ1xuICBwcm9kdWN0VHlwZT86IHN0cmluZ1xuICBjb3N0UHJpY2U6IG51bWJlclxuICByZXRhaWxQcmljZTogbnVtYmVyXG4gIG1hcmdpbjogbnVtYmVyXG4gIHN0YXR1czogUHJvZHVjdFN0YXR1c1xuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICBxdWFudGl0eT86IG51bWJlclxuICB3YXJlaG91c2U/OiBzdHJpbmdcbiAgcmVzdG9ja1RocmVzaG9sZD86IG51bWJlclxuICBpbWFnZXM/OiBzdHJpbmdbXVxuICBub3Rlcz86IE5vdGVFbnRyeVtdXG4gIHRhZ3M/OiBzdHJpbmdbXVxufVxuXG4vLyBBZGQgYSBuZXcgaW50ZXJmYWNlIGZvciBub3RlIGVudHJpZXNcbmV4cG9ydCBpbnRlcmZhY2UgTm90ZUVudHJ5IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZXh0OiBzdHJpbmdcbiAgdGltZXN0YW1wOiBEYXRlXG4gIHVzZXI6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgUHJvZHVjdFN0b3JlIHtcbiAgcHJvZHVjdHM6IFByb2R1Y3RbXVxuICBmaWx0ZXJlZFByb2R1Y3RzOiBQcm9kdWN0W11cbiAgc2VhcmNoVGVybTogc3RyaW5nXG4gIHN0YXR1c0ZpbHRlcjogUHJvZHVjdFN0YXR1cyB8IFwiYWxsXCJcbiAgY29sbGVjdGlvbkZpbHRlcjogc3RyaW5nXG4gIHRhZ0ZpbHRlcjogc3RyaW5nW11cblxuICBzZXRTZWFyY2hUZXJtOiAodGVybTogc3RyaW5nKSA9PiB2b2lkXG4gIHNldFN0YXR1c0ZpbHRlcjogKHN0YXR1czogUHJvZHVjdFN0YXR1cyB8IFwiYWxsXCIpID0+IHZvaWRcbiAgc2V0Q29sbGVjdGlvbkZpbHRlcjogKGNvbGxlY3Rpb246IHN0cmluZykgPT4gdm9pZFxuICBzZXRUYWdGaWx0ZXI6ICh0YWdzOiBzdHJpbmdbXSkgPT4gdm9pZFxuXG4gIGFkZFByb2R1Y3Q6IChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsIFwiaWRcIiB8IFwibWFyZ2luXCI+KSA9PiB2b2lkXG4gIHVwZGF0ZVByb2R1Y3Q6IChpZDogc3RyaW5nLCBwcm9kdWN0OiBQYXJ0aWFsPFByb2R1Y3Q+KSA9PiB2b2lkXG4gIGFyY2hpdmVQcm9kdWN0OiAoaWQ6IHN0cmluZykgPT4gdm9pZFxuICBkdXBsaWNhdGVQcm9kdWN0OiAoaWQ6IHN0cmluZykgPT4gdm9pZFxuICBidWxrQXJjaGl2ZTogKGlkczogc3RyaW5nW10pID0+IHZvaWRcbiAgYnVsa0R1cGxpY2F0ZTogKGlkczogc3RyaW5nW10pID0+IHZvaWRcbiAgLy8gQWRkIHRoZXNlIGZ1bmN0aW9ucyB0byB0aGUgUHJvZHVjdFN0b3JlIGludGVyZmFjZVxuICBpc1NrdVVuaXF1ZTogKHNrdTogc3RyaW5nLCBjdXJyZW50UHJvZHVjdElkPzogc3RyaW5nKSA9PiBib29sZWFuXG4gIGdldEF2YWlsYWJsZVByb2R1Y3RUeXBlczogKCkgPT4gc3RyaW5nW11cbiAgYWRkQ29sbGVjdGlvbjogKGNvbGxlY3Rpb246IHN0cmluZykgPT4gdm9pZFxuICBhZGRXYXJlaG91c2U6ICh3YXJlaG91c2U6IHN0cmluZykgPT4gdm9pZFxuICByZW1vdmVXYXJlaG91c2U6ICh3YXJlaG91c2U6IHN0cmluZykgPT4gdm9pZFxuICBidWxrQ2hhbmdlQ29sbGVjdGlvbjogKGlkczogc3RyaW5nW10sIGNvbGxlY3Rpb246IHN0cmluZykgPT4gdm9pZFxuICBidWxrQWRkVGFnczogKGlkczogc3RyaW5nW10sIHRhZ3M6IHN0cmluZ1tdKSA9PiB2b2lkXG4gIGJ1bGtEZWxldGU6IChpZHM6IHN0cmluZ1tdKSA9PiB2b2lkXG4gIGFkZE5vdGVUb1Byb2R1Y3Q6IChpZDogc3RyaW5nLCBub3RlOiBzdHJpbmcpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVByb2R1Y3RTdG9yZSA9IGNyZWF0ZTxQcm9kdWN0U3RvcmU+KChzZXQsIGdldCkgPT4gKHtcbiAgcHJvZHVjdHM6IG1vY2tQcm9kdWN0cyxcbiAgZmlsdGVyZWRQcm9kdWN0czogbW9ja1Byb2R1Y3RzLFxuICBzZWFyY2hUZXJtOiBcIlwiLFxuICBzdGF0dXNGaWx0ZXI6IFwiYWxsXCIsXG4gIGNvbGxlY3Rpb25GaWx0ZXI6IFwiXCIsXG4gIHRhZ0ZpbHRlcjogW10sXG5cbiAgc2V0U2VhcmNoVGVybTogKHRlcm0pID0+IHtcbiAgICBzZXQoeyBzZWFyY2hUZXJtOiB0ZXJtIH0pXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIHNldFN0YXR1c0ZpbHRlcjogKHN0YXR1cykgPT4ge1xuICAgIHNldCh7IHN0YXR1c0ZpbHRlcjogc3RhdHVzIH0pXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIHNldENvbGxlY3Rpb25GaWx0ZXI6IChjb2xsZWN0aW9uKSA9PiB7XG4gICAgc2V0KHsgY29sbGVjdGlvbkZpbHRlcjogY29sbGVjdGlvbiB9KVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBzZXRUYWdGaWx0ZXI6ICh0YWdzKSA9PiB7XG4gICAgc2V0KHsgdGFnRmlsdGVyOiB0YWdzIH0pXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuXG4gIGFkZFByb2R1Y3Q6IChwcm9kdWN0RGF0YSkgPT4ge1xuICAgIGNvbnN0IGlkID0gYFBSRC0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gXG4gICAgY29uc3QgbWFyZ2luID0gY2FsY3VsYXRlTWFyZ2luKHByb2R1Y3REYXRhLmNvc3RQcmljZSwgcHJvZHVjdERhdGEucmV0YWlsUHJpY2UpXG5cbiAgICBjb25zdCBuZXdQcm9kdWN0ID0ge1xuICAgICAgLi4ucHJvZHVjdERhdGEsXG4gICAgICBpZCxcbiAgICAgIG1hcmdpbixcbiAgICB9XG5cbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IFsuLi5zdGF0ZS5wcm9kdWN0cywgbmV3UHJvZHVjdF0sXG4gICAgfSkpXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgdXBkYXRlUHJvZHVjdDogKGlkLCBwcm9kdWN0RGF0YSkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0cyA9IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT4ge1xuICAgICAgICBpZiAocHJvZHVjdC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBtYXJnaW4gaWYgcHJpY2VzIGNoYW5nZWRcbiAgICAgICAgICBsZXQgbWFyZ2luID0gcHJvZHVjdC5tYXJnaW5cbiAgICAgICAgICBpZiAocHJvZHVjdERhdGEuY29zdFByaWNlICE9PSB1bmRlZmluZWQgJiYgcHJvZHVjdERhdGEucmV0YWlsUHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFyZ2luID0gY2FsY3VsYXRlTWFyZ2luKHByb2R1Y3REYXRhLmNvc3RQcmljZSwgcHJvZHVjdERhdGEucmV0YWlsUHJpY2UpXG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0RGF0YS5jb3N0UHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFyZ2luID0gY2FsY3VsYXRlTWFyZ2luKHByb2R1Y3REYXRhLmNvc3RQcmljZSwgcHJvZHVjdC5yZXRhaWxQcmljZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3REYXRhLnJldGFpbFByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IGNhbGN1bGF0ZU1hcmdpbihwcm9kdWN0LmNvc3RQcmljZSwgcHJvZHVjdERhdGEucmV0YWlsUHJpY2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucHJvZHVjdCwgLi4ucHJvZHVjdERhdGEsIG1hcmdpbiB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2R1Y3RcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7IHByb2R1Y3RzOiB1cGRhdGVkUHJvZHVjdHMgfVxuICAgIH0pXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYXJjaGl2ZVByb2R1Y3Q6IChpZCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PiAocHJvZHVjdC5pZCA9PT0gaWQgPyB7IC4uLnByb2R1Y3QsIHN0YXR1czogXCJhcmNoaXZlZFwiIH0gOiBwcm9kdWN0KSksXG4gICAgfSkpXG5cbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgZHVwbGljYXRlUHJvZHVjdDogKGlkKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdFRvRHVwbGljYXRlID0gc3RhdGUucHJvZHVjdHMuZmluZCgocCkgPT4gcC5pZCA9PT0gaWQpXG4gICAgICBpZiAoIXByb2R1Y3RUb0R1cGxpY2F0ZSkgcmV0dXJuIHN0YXRlXG5cbiAgICAgIGNvbnN0IG5ld0lkID0gYFBSRC0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gXG4gICAgICBjb25zdCBkdXBsaWNhdGVkUHJvZHVjdCA9IHtcbiAgICAgICAgLi4ucHJvZHVjdFRvRHVwbGljYXRlLFxuICAgICAgICBpZDogbmV3SWQsXG4gICAgICAgIG5hbWU6IGAke3Byb2R1Y3RUb0R1cGxpY2F0ZS5uYW1lfSAoQ29weSlgLFxuICAgICAgICBza3U6IGAke3Byb2R1Y3RUb0R1cGxpY2F0ZS5za3V9LUNPUFlgLFxuICAgICAgICBzdGF0dXM6IFwiZHJhZnRcIiBhcyBQcm9kdWN0U3RhdHVzLFxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9kdWN0czogWy4uLnN0YXRlLnByb2R1Y3RzLCBkdXBsaWNhdGVkUHJvZHVjdF0sXG4gICAgICB9XG4gICAgfSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBidWxrQXJjaGl2ZTogKGlkcykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PlxuICAgICAgICBpZHMuaW5jbHVkZXMocHJvZHVjdC5pZCkgPyB7IC4uLnByb2R1Y3QsIHN0YXR1czogXCJhcmNoaXZlZFwiIH0gOiBwcm9kdWN0LFxuICAgICAgKSxcbiAgICB9KSlcblxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBidWxrRHVwbGljYXRlOiAoaWRzKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdHNUb0R1cGxpY2F0ZSA9IHN0YXRlLnByb2R1Y3RzLmZpbHRlcigocCkgPT4gaWRzLmluY2x1ZGVzKHAuaWQpKVxuICAgICAgY29uc3QgZHVwbGljYXRlZFByb2R1Y3RzID0gcHJvZHVjdHNUb0R1cGxpY2F0ZS5tYXAoKHByb2R1Y3QpID0+ICh7XG4gICAgICAgIC4uLnByb2R1Y3QsXG4gICAgICAgIGlkOiBgUFJELSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApfWAsXG4gICAgICAgIG5hbWU6IGAke3Byb2R1Y3QubmFtZX0gKENvcHkpYCxcbiAgICAgICAgc2t1OiBgJHtwcm9kdWN0LnNrdX0tQ09QWWAsXG4gICAgICAgIHN0YXR1czogXCJkcmFmdFwiIGFzIFByb2R1Y3RTdGF0dXMsXG4gICAgICB9KSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZHVjdHM6IFsuLi5zdGF0ZS5wcm9kdWN0cywgLi4uZHVwbGljYXRlZFByb2R1Y3RzXSxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgYXBwbHlGaWx0ZXJzKGdldCwgc2V0KVxuICB9LFxuICAvLyBBZGQgdGhlc2UgaW1wbGVtZW50YXRpb25zIHRvIHRoZSBzdG9yZSBjcmVhdGlvblxuICBpc1NrdVVuaXF1ZTogKHNrdSwgY3VycmVudFByb2R1Y3RJZCkgPT4ge1xuICAgIGNvbnN0IHByb2R1Y3RzID0gZ2V0KCkucHJvZHVjdHNcbiAgICByZXR1cm4gIXByb2R1Y3RzLnNvbWUoKHByb2R1Y3QpID0+IHByb2R1Y3Quc2t1ID09PSBza3UgJiYgcHJvZHVjdC5pZCAhPT0gY3VycmVudFByb2R1Y3RJZClcbiAgfSxcblxuICBnZXRBdmFpbGFibGVQcm9kdWN0VHlwZXM6ICgpID0+IFtcbiAgICBcIlQtc2hpcnRcIixcbiAgICBcIkhvb2RpZVwiLFxuICAgIFwiU3dlYXRzaGlydFwiLFxuICAgIFwiSmFja2V0XCIsXG4gICAgXCJQYW50c1wiLFxuICAgIFwiU2hvcnRzXCIsXG4gICAgXCJIYXRcIixcbiAgICBcIkFjY2Vzc29yeVwiLFxuICAgIFwiRm9vdHdlYXJcIixcbiAgICBcIk90aGVyXCIsXG4gIF0sXG5cbiAgYWRkQ29sbGVjdGlvbjogKGNvbGxlY3Rpb24pID0+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGFkZCB0byBhIGRhdGFiYXNlXG4gICAgLy8gRm9yIHRoaXMgZGVtbywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBhcyB3ZSdsbCBqdXN0IHVzZSB0aGUgdmFsdWUgZGlyZWN0bHlcbiAgfSxcblxuICBhZGRXYXJlaG91c2U6ICh3YXJlaG91c2UpID0+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGFkZCB0byBhIGRhdGFiYXNlXG4gICAgLy8gRm9yIHRoaXMgZGVtbywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBhcyB3ZSdsbCBqdXN0IHVzZSB0aGUgdmFsdWUgZGlyZWN0bHlcbiAgfSxcblxuICByZW1vdmVXYXJlaG91c2U6ICh3YXJlaG91c2UpID0+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIHJlbW92ZSBmcm9tIGEgZGF0YWJhc2UgYW5kIHVwZGF0ZSBwcm9kdWN0c1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBwcm9kdWN0czogc3RhdGUucHJvZHVjdHMubWFwKChwcm9kdWN0KSA9PlxuICAgICAgICBwcm9kdWN0LndhcmVob3VzZSA9PT0gd2FyZWhvdXNlID8geyAuLi5wcm9kdWN0LCB3YXJlaG91c2U6IFwiXCIgfSA6IHByb2R1Y3QsXG4gICAgICApLFxuICAgIH0pKVxuICB9LFxuXG4gIGJ1bGtDaGFuZ2VDb2xsZWN0aW9uOiAoaWRzLCBjb2xsZWN0aW9uKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5tYXAoKHByb2R1Y3QpID0+IChpZHMuaW5jbHVkZXMocHJvZHVjdC5pZCkgPyB7IC4uLnByb2R1Y3QsIGNvbGxlY3Rpb24gfSA6IHByb2R1Y3QpKSxcbiAgICB9KSlcbiAgICBhcHBseUZpbHRlcnMoZ2V0LCBzZXQpXG4gIH0sXG5cbiAgYnVsa0FkZFRhZ3M6IChpZHMsIHRhZ3MpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT4ge1xuICAgICAgICBpZiAoaWRzLmluY2x1ZGVzKHByb2R1Y3QuaWQpKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRhZ3MgPSBwcm9kdWN0LnRhZ3MgfHwgW11cbiAgICAgICAgICBjb25zdCBuZXdUYWdzID0gWy4uLm5ldyBTZXQoWy4uLmN1cnJlbnRUYWdzLCAuLi50YWdzXSldXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucHJvZHVjdCwgdGFnczogbmV3VGFncyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2R1Y3RcbiAgICAgIH0pLFxuICAgIH0pKVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBidWxrRGVsZXRlOiAoaWRzKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHByb2R1Y3RzOiBzdGF0ZS5wcm9kdWN0cy5maWx0ZXIoKHByb2R1Y3QpID0+ICFpZHMuaW5jbHVkZXMocHJvZHVjdC5pZCkpLFxuICAgIH0pKVxuICAgIGFwcGx5RmlsdGVycyhnZXQsIHNldClcbiAgfSxcblxuICBhZGROb3RlVG9Qcm9kdWN0OiAoaWQsIG5vdGUpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcHJvZHVjdHM6IHN0YXRlLnByb2R1Y3RzLm1hcCgocHJvZHVjdCkgPT4ge1xuICAgICAgICBpZiAocHJvZHVjdC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICBjb25zdCBub3RlRW50cnk6IE5vdGVFbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiBgbm90ZS0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIHRleHQ6IG5vdGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1c2VyOiBcIkN1cnJlbnQgVXNlclwiLCAvLyBJbiBhIHJlYWwgYXBwLCBnZXQgZnJvbSBhdXRoIGNvbnRleHRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VycmVudE5vdGVzID0gcHJvZHVjdC5ub3RlcyB8fCBbXVxuICAgICAgICAgIHJldHVybiB7IC4uLnByb2R1Y3QsIG5vdGVzOiBbbm90ZUVudHJ5LCAuLi5jdXJyZW50Tm90ZXNdIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZHVjdFxuICAgICAgfSksXG4gICAgfSkpXG4gIH0sXG59KSlcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBtYXJnaW5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hcmdpbihjb3N0UHJpY2U6IG51bWJlciwgcmV0YWlsUHJpY2U6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChjb3N0UHJpY2UgPT09IDApIHJldHVybiAwXG4gIHJldHVybiBNYXRoLnJvdW5kKCgocmV0YWlsUHJpY2UgLSBjb3N0UHJpY2UpIC8gcmV0YWlsUHJpY2UpICogMTAwKVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgYWxsIGZpbHRlcnNcbmZ1bmN0aW9uIGFwcGx5RmlsdGVycyhnZXQ6IGFueSwgc2V0OiBhbnkpIHtcbiAgY29uc3QgeyBwcm9kdWN0cywgc2VhcmNoVGVybSwgc3RhdHVzRmlsdGVyLCBjb2xsZWN0aW9uRmlsdGVyLCB0YWdGaWx0ZXIgfSA9IGdldCgpXG5cbiAgbGV0IGZpbHRlcmVkID0gWy4uLnByb2R1Y3RzXVxuXG4gIC8vIEFwcGx5IHNlYXJjaCBmaWx0ZXJcbiAgaWYgKHNlYXJjaFRlcm0pIHtcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpXG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAocHJvZHVjdCkgPT4gcHJvZHVjdC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHwgcHJvZHVjdC5za3UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSxcbiAgICApXG4gIH1cblxuICAvLyBBcHBseSBzdGF0dXMgZmlsdGVyXG4gIGlmIChzdGF0dXNGaWx0ZXIgIT09IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcigocHJvZHVjdCkgPT4gcHJvZHVjdC5zdGF0dXMgPT09IHN0YXR1c0ZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IGNvbGxlY3Rpb24gZmlsdGVyXG4gIGlmIChjb2xsZWN0aW9uRmlsdGVyKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QuY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbkZpbHRlcilcbiAgfVxuXG4gIC8vIEFwcGx5IHRhZyBmaWx0ZXJcbiAgaWYgKHRhZ0ZpbHRlci5sZW5ndGggPiAwKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHByb2R1Y3QpID0+IHByb2R1Y3QudGFncz8uc29tZSgodGFnKSA9PiB0YWdGaWx0ZXIuaW5jbHVkZXModGFnKSkpXG4gIH1cblxuICBzZXQoeyBmaWx0ZXJlZFByb2R1Y3RzOiBmaWx0ZXJlZCB9KVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsIm1vY2tQcm9kdWN0cyIsInVzZVByb2R1Y3RTdG9yZSIsInNldCIsImdldCIsInByb2R1Y3RzIiwiZmlsdGVyZWRQcm9kdWN0cyIsInNlYXJjaFRlcm0iLCJzdGF0dXNGaWx0ZXIiLCJjb2xsZWN0aW9uRmlsdGVyIiwidGFnRmlsdGVyIiwic2V0U2VhcmNoVGVybSIsInRlcm0iLCJhcHBseUZpbHRlcnMiLCJzZXRTdGF0dXNGaWx0ZXIiLCJzdGF0dXMiLCJzZXRDb2xsZWN0aW9uRmlsdGVyIiwiY29sbGVjdGlvbiIsInNldFRhZ0ZpbHRlciIsInRhZ3MiLCJhZGRQcm9kdWN0IiwicHJvZHVjdERhdGEiLCJpZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm1hcmdpbiIsImNhbGN1bGF0ZU1hcmdpbiIsImNvc3RQcmljZSIsInJldGFpbFByaWNlIiwibmV3UHJvZHVjdCIsInN0YXRlIiwidXBkYXRlUHJvZHVjdCIsInVwZGF0ZWRQcm9kdWN0cyIsIm1hcCIsInByb2R1Y3QiLCJ1bmRlZmluZWQiLCJhcmNoaXZlUHJvZHVjdCIsImR1cGxpY2F0ZVByb2R1Y3QiLCJwcm9kdWN0VG9EdXBsaWNhdGUiLCJmaW5kIiwicCIsIm5ld0lkIiwiZHVwbGljYXRlZFByb2R1Y3QiLCJuYW1lIiwic2t1IiwiYnVsa0FyY2hpdmUiLCJpZHMiLCJpbmNsdWRlcyIsImJ1bGtEdXBsaWNhdGUiLCJwcm9kdWN0c1RvRHVwbGljYXRlIiwiZmlsdGVyIiwiZHVwbGljYXRlZFByb2R1Y3RzIiwiaXNTa3VVbmlxdWUiLCJjdXJyZW50UHJvZHVjdElkIiwic29tZSIsImdldEF2YWlsYWJsZVByb2R1Y3RUeXBlcyIsImFkZENvbGxlY3Rpb24iLCJhZGRXYXJlaG91c2UiLCJ3YXJlaG91c2UiLCJyZW1vdmVXYXJlaG91c2UiLCJidWxrQ2hhbmdlQ29sbGVjdGlvbiIsImJ1bGtBZGRUYWdzIiwiY3VycmVudFRhZ3MiLCJuZXdUYWdzIiwiU2V0IiwiYnVsa0RlbGV0ZSIsImFkZE5vdGVUb1Byb2R1Y3QiLCJub3RlIiwibm90ZUVudHJ5IiwiRGF0ZSIsIm5vdyIsInRleHQiLCJ0aW1lc3RhbXAiLCJ1c2VyIiwiY3VycmVudE5vdGVzIiwibm90ZXMiLCJyb3VuZCIsImZpbHRlcmVkIiwidG9Mb3dlckNhc2UiLCJsZW5ndGgiLCJ0YWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/products/product-store.ts\n"));

/***/ })

});